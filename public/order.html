<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sipariş Adımları</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <div class="container">
    <a href="/" class="small">← Yeni sorgu</a>
    <h1>Sipariş <span id="orderNo"></span></h1>

    <div class="card unified">
      <div class="unifiedGrid">
        <div class="currentBox">
          <div class="title">Mevcut adım</div>
          <div class="currentNum" id="currentStep">-</div>
        </div>
        <div class="stepList">
          <div class="title">Adım listesi</div>
          <div class="window7" id="window7"></div>
        </div>
        <div class="progressBadge" id="progress">0 / 0</div>
      </div>
    </div>

    <div class="controls">
      <button id="prev" class="btn" title="Önceki (←)">Önceki</button>
      <button id="next" class="btn" title="Sonraki (→)">Sonraki</button>
      <button id="play" class="btn" aria-pressed="false" title="Oynat/Duraklat (Space)">▶ / ⏸</button>
      <input id="intervalSec" class="spin" type="number" min="1" step="1" value="5" title="Süre (saniye)" />
      <input id="jumpInput" class="spin" type="text" placeholder="Adıma git" />
      <button id="jumpBtn" class="btn">Git</button>
    </div>
  </div>

  <script>
    function getOrderFromPath(){ const parts = window.location.pathname.split('/'); return decodeURIComponent(parts[2] || ''); }
    const orderNo = getOrderFromPath(); document.getElementById('orderNo').textContent = orderNo;

    const state = { steps: [], index: 0, timer: null };

    async function load(){
      const res = await fetch('/api/order/' + encodeURIComponent(orderNo));
      if(!res.ok){ alert('Kayıt bulunamadı.'); location.href='/'; return; }
      const arr = await res.json();
      state.steps = Array.isArray(arr) ? arr : (arr.steps || []);
      state.index = 0; render();
    }

    function render(){
      const cur = state.steps[state.index];
      document.getElementById('currentStep').textContent = cur ? cur.notch : '-';
      document.getElementById('progress').textContent = `${state.index+1} / ${state.steps.length}`;

      // Build 7-slot vertical window with blanks at head/tail
      const win = document.getElementById('window7');
      win.innerHTML = '';
      const total = state.steps.length;
      const i = state.index;

      let start = i - 3;
      let end = i + 3;
      if (start < 0) { end += -start; start = 0; }
      if (end > total - 1) { start -= (end - (total - 1)); end = total - 1; }
      if (start < 0) start = 0;

      const slots = [];
      for (let k = start; k <= end; k++) slots.push({ idx: k, val: state.steps[k].notch });
      while (slots.length < 7) {
        if (start === 0) slots.unshift({ idx: null, val: "" });
        else slots.push({ idx: null, val: "" });
      }

      for (let s = 0; s < 7; s++) {
        const div = document.createElement('div');
        const isCurrent = slots[s].idx === i;
        div.className = 'slot' + (isCurrent ? ' current' : '');
        div.textContent = slots[s].val === undefined ? '' : slots[s].val;
        win.appendChild(div);
      }
    }

    function next(){ if(state.index < state.steps.length - 1){ state.index++; render(); } else { stop(); } }
    function prev(){ if(state.index > 0){ state.index--; render(); } }
    function getIntervalMs(){ const sec = parseInt(document.getElementById('intervalSec').value,10); return (Number.isFinite(sec)&&sec>=1?sec:5)*1000; }
    function play(){ if(state.timer) return; state.timer=setInterval(next, getIntervalMs()); document.getElementById('play').setAttribute('aria-pressed','true'); document.getElementById('play').textContent='⏸'; }
    function stop(){ if(state.timer){ clearInterval(state.timer); state.timer=null; document.getElementById('play').setAttribute('aria-pressed','false'); document.getElementById('play').textContent='▶'; } }

    document.getElementById('prev').onclick = prev;
    document.getElementById('next').onclick = next;
    document.getElementById('play').onclick = () => state.timer ? stop() : play();
    document.getElementById('intervalSec').addEventListener('change', () => { if(state.timer){ stop(); play(); } });
    document.getElementById('jumpBtn').onclick = () => {
      const v = parseInt(document.getElementById('jumpInput').value,10);
      if(Number.isFinite(v)){ const idx=v-1; if(idx>=0 && idx < state.steps.length){ state.index = idx; render(); } }
    };
    window.addEventListener('keydown', (e) => {
      if(e.key === 'ArrowRight') next();
      if(e.key === 'ArrowLeft') prev();
      if(e.code === 'Space'){ e.preventDefault(); state.timer ? stop() : play(); }
    });

    
    function fitCurrentNumber(){
      const el = document.getElementById('currentStep');
      if(!el) return;
      // el is the .currentNum (fills its grid row)
      const boxW = el.clientWidth;
      const boxH = el.clientHeight;
      if (!boxW || !boxH) return;
      const text = el.textContent || '';
      // Early return for empty
      if (!text) return;

      let lo = 16, hi = 400, best = 16;
      const paddingFactor = 0.9; // keep 10% breathing space

      // Save original styles
      const old = el.style.fontSize;

      while (lo <= hi){
        const mid = Math.floor((lo+hi)/2);
        el.style.fontSize = mid + 'px';
        // measure
        const fits = (el.scrollWidth <= boxW * paddingFactor) && (el.scrollHeight <= boxH * paddingFactor);
        if (fits){ best = mid; lo = mid + 1; } else { hi = mid - 1; }
      }
      el.style.fontSize = best + 'px';
    }

    window.addEventListener('resize', () => { fitCurrentNumber(); });

    load();
  </script>
</body>
</html>
